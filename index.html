<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic Tarot V12 - AR Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #eee; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
        .status-box { background: rgba(10, 16, 30, 0.8); padding: 10px 15px; border-radius: 8px; border: 1px solid #ff4a4a; box-shadow: 0 0 20px rgba(255, 74, 74, 0.1); backdrop-filter: blur(10px); max-width: 60%; }
        h1 { margin: 0; font-size: 1.2rem; color: #ff4a4a; text-transform: uppercase; letter-spacing: 2px; font-weight: 300; text-shadow: 0 0 10px rgba(255, 74, 74, 0.5); }
        .sub-text { font-size: 0.7rem; color: #ffaaaa; margin-top: 5px; letter-spacing: 1px; }
        
        /* 开启摄像头按钮 */
        .mode-btn { background: rgba(0,0,0,0.5); color: #4affff; border: 1px solid #4affff; padding: 8px 12px; cursor: pointer; transition: 0.3s; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; border-radius: 4px; pointer-events: auto; }
        .mode-btn.active { background: #4affff; color: #000; box-shadow: 0 0 15px #4affff; }

        /* 撕碎按钮 */
        #tear-btn {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 74, 74, 0.2); color: #fff; border: 1px solid #ff4a4a;
            padding: 15px 40px; border-radius: 30px; font-size: 1rem; letter-spacing: 3px;
            text-transform: uppercase; pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 20px #ff4a4a; display: none; z-index: 100;
            backdrop-filter: blur(5px); transition: 0.2s;
        }
        #tear-btn:active { background: #ff4a4a; color: #000; transform: translateX(-50%) scale(0.95); }

        #card-info { position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.3s; width: 90%; z-index: 5; }
        #card-name { font-size: 2rem; color: #fff; margin-bottom: 5px; font-weight: 100; text-shadow: 0 0 20px rgba(255,255,255,0.5); letter-spacing: 2px; }
        #card-meaning { font-size: 0.9rem; color: #ccc; background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent); padding: 10px; display: inline-block; width: 100%; }
        
        /* 摄像头小窗口 */
        #input-video { position: absolute; bottom: 20px; right: 20px; width: 80px; opacity: 0.6; transform: scaleX(-1); border: 2px solid #4affff; pointer-events: auto; display: none; z-index: 100; border-radius: 4px; }
        #input-video.active { display: block; }

        #cursor-tracker {
            position: absolute; width: 40px; height: 40px; 
            border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; z-index: 50; 
            transition: width 0.1s, height 0.1s, border-color 0.2s;
            display: none; /* 默认隐藏，开启摄像头后显示 */
        }
        #cursor-tracker.hovering { border-color: #ff4a4a; box-shadow: 0 0 15px #ff4a4a; transform: translate(-50%, -50%) scale(1.1); }
        #cursor-tracker.pinching { width: 20px; height: 20px; background-color: rgba(255, 74, 74, 0.5); border-color: #fff; }

        #loading { position: fixed; inset: 0; background: #050505; z-index: 999; display: flex; justify-content: center; align-items: center; color: #ff4a4a; flex-direction: column; transition: opacity 1s; }
        .spinner { width: 50px; height: 50px; border: 2px solid #111; border-top: 2px solid #ff4a4a; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #tear-flash { position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 99; transition: opacity 0.1s; }
        #instructions { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #755; font-size: 0.7rem; letter-spacing: 2px; text-transform: uppercase; padding: 0 10px; box-sizing: border-box; pointer-events: none;}

        @media (max-width: 600px) {
            #card-name { font-size: 1.8rem; }
            #card-meaning { font-size: 0.85rem; }
            .status-box h1 { font-size: 1rem; }
            #tear-btn { bottom: 15%; }
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">DECK SHUFFLING...</div>
    </div>
    
    <div id="tear-flash"></div>
    <div id="canvas-container"></div>
    <!-- 只有在摄像头开启时才显示光标 -->
    <div id="cursor-tracker"></div>
    <video id="input-video" playsinline></video>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-box">
                <h1>FATE TEARER</h1>
                <div id="status-text" class="sub-text">Mobile V13</div>
            </div>
            <!-- 摄像头开关 -->
            <button class="mode-btn" id="toggle-cam">开启摄像头</button>
        </div>
        
        <div id="card-info">
            <div id="card-name"></div>
            <div id="card-meaning"></div>
        </div>

        <button id="tear-btn">TEAR FATE</button>
        <div id="instructions">触摸操作模式: 滑动/点击</div>
    </div>

<script>
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const CONFIG = { localPath: './images/', fallbackUrlBase: 'https://upload.wikimedia.org/wikipedia/commons/', carouselSpacing: 5.0, destroyDelay: 1000, cardSize: { w: 3.4, h: 5.6, d: 0.12 } };
const TAROT_DB = [
    { id: '00', filename: 'maj00.jpeg', fallback: '9/90/RWS_Tarot_00_Fool.jpg', name: "The Fool", upright: "新的开始，冒险，无限潜力", reversed: "鲁莽，不顾后果" },
    { id: '01', filename: 'maj01.jpeg', fallback: 'd/de/RWS_Tarot_01_Magician.jpg', name: "The Magician", upright: "创造力，意志，显化", reversed: "操纵，未发掘的才能" },
    { id: '02', filename: 'maj02.jpeg', fallback: '8/88/RWS_Tarot_02_High_Priestess.jpg', name: "High Priestess", upright: "直觉，潜意识，神秘", reversed: "压抑情感，秘密" },
    { id: '03', filename: 'maj03.jpeg', fallback: 'd/d2/RWS_Tarot_03_Empress.jpg', name: "The Empress", upright: "丰饶，自然，母性", reversed: "依赖，创造力受阻" },
    { id: '04', filename: 'maj04.jpeg', fallback: 'c/c3/RWS_Tarot_04_Emperor.jpg', name: "The Emperor", upright: "权威，结构，控制", reversed: "暴政，僵化" },
    { id: '05', filename: 'maj05.jpeg', fallback: '8/8d/RWS_Tarot_05_Hierophant.jpg', name: "The Hierophant", upright: "传统，信仰，教育", reversed: "反叛，非常规" },
    { id: '06', filename: 'maj06.jpeg', fallback: '3/3a/RWS_Tarot_06_Lovers.jpg', name: "The Lovers", upright: "爱，和谐，选择", reversed: "不和谐，分离" },
    { id: '07', filename: 'maj07.jpeg', fallback: '9/9b/RWS_Tarot_07_Chariot.jpg', name: "The Chariot", upright: "胜利，意志力，自律", reversed: "失控，侵略性" },
    { id: '09', filename: 'maj08.jpeg', fallback: '4/4d/RWS_Tarot_09_Hermit.jpg', name: "The Hermit", upright: "内省，孤独，指引", reversed: "孤立，退缩" },
    { id: '10', filename: 'maj09.jpeg', fallback: '3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg', name: "Wheel of Fortune", upright: "命运，转折点，周期", reversed: "厄运，抵抗变化" }
];

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const SoundFX = {
    playSelect: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    },
    playSwipe: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime; const bufferSize = audioCtx.sampleRate * 0.15; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
        const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(600, t); filter.frequency.linearRampToValueAtTime(100, t + 0.15);
        const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.14);
        noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noise.start();
    },
    playFlip: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime; const bufferSize = audioCtx.sampleRate * 0.4; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
        const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(100, t); filter.frequency.linearRampToValueAtTime(1500, t + 0.15);
        const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t + 0.1); gain.gain.linearRampToValueAtTime(0, t + 0.3);
        noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noise.start();
    },
    playTear: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime; const bufferSize = audioCtx.sampleRate * 0.4; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0); let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
        for (let i = 0; i < bufferSize; i++) { const white = Math.random() * 2 - 1; b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759; b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856; b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980; data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; data[i] *= 0.11; b6 = white * 0.115926; }
        const source = audioCtx.createBufferSource(); source.buffer = buffer; const filter = audioCtx.createBiquadFilter(); filter.type = 'bandpass'; filter.Q.value = 1; filter.frequency.setValueAtTime(400, t); filter.frequency.exponentialRampToValueAtTime(4000, t + 0.15); 
        const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.8, t + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25); 
        source.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); source.start(); source.stop(t + 0.3);
    }
};

const STATE = { CAROUSEL: 0, GRABBED: 1, REVEALED: 2, TEARING: 3 };
const INPUT = { MOUSE: 'mouse', HANDS: 'hands' };

let currentState = STATE.CAROUSEL;
let inputMode = INPUT.MOUSE; // 默认鼠标/触摸模式
let scene, camera, renderer, clock;
let starField, raycaster, mouse;
let textureLoader;
let bgDeck = [];
let activeCard = null;
let tornParts = []; 
let activeIndex = 0; 
let lastRoundIndex = 0;
let smoothIndex = 0; 
let isReversed = false;
let cursor = { x: 0, y: 0 }; 
let isPinching = false;
let isFist = false;
let swipeVelocity = 0;
let baseCameraZ = 12;
let cameraActive = false;
let handLandmarker = null;
let cameraObj = null;

async function init() {
    setupThree();
    setupUniverse();
    textureLoader = new THREE.TextureLoader();
    await createDeck();
    setupInput();
    document.getElementById('loading').style.opacity = 0;
    setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);
    clock = new THREE.Clock();
    animate();
}

function setupThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050508); 
    scene.fog = new THREE.FogExp2(0x050508, 0.02);
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    adjustCameraPosition();
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.shadowMap.enabled = true; 
    container.appendChild(renderer.domElement);
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffddaa, 1.2);
    sun.position.set(5, 10, 10); sun.castShadow = true; scene.add(sun);
    const rim = new THREE.PointLight(0x4488ff, 1.5, 20);
    rim.position.set(-5, 2, -5); scene.add(rim);
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('resize', onWindowResize);
}

function adjustCameraPosition() {
    const aspect = window.innerWidth / window.innerHeight;
    if (aspect < 1) camera.position.set(0, 0, baseCameraZ + (1/aspect) * 4); 
    else camera.position.set(0, 0, baseCameraZ);
}
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    adjustCameraPosition();
}
function setupUniverse() {
    const count = 2000; const geo = new THREE.BufferGeometry(); const pos = [];
    for(let i=0; i<count; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*50 - 20);
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0x8888aa, size: 0.1, transparent: true, opacity: 0.6 });
    starField = new THREE.Points(geo, mat); scene.add(starField);
}
async function createDeck() {
    const backTex = createCardBackTexture();
    const geo = new THREE.BoxGeometry(CONFIG.cardSize.w, CONFIG.cardSize.h, CONFIG.cardSize.d);
    const edgeMat = new THREE.MeshStandardMaterial({ color: 0x8a6030, roughness: 0.3, metalness: 0.8 });
    for (let i = 0; i < TAROT_DB.length; i++) {
        const data = TAROT_DB[i]; const group = new THREE.Group();
        const frontTex = await loadCardTexture(data);
        const frontMat = new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4, metalness: 0.1 });
        const backMat = new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.5, metalness: 0.2 });
        const materials = [edgeMat, edgeMat, edgeMat, edgeMat, frontMat, backMat];
        const cardMesh = new THREE.Mesh(geo, materials);
        cardMesh.name = "cardBody"; cardMesh.castShadow = true; cardMesh.receiveShadow = true;
        group.add(cardMesh); group.userData = { id: i, data: data }; group.rotation.y = Math.PI; 
        scene.add(group); bgDeck.push(group);
    }
}
function loadCardTexture(cardData) {
    return new Promise((resolve) => {
        textureLoader.load(CONFIG.localPath + cardData.filename, (tex) => { tex.flipY = false; resolve(tex); }, undefined, 
            () => { textureLoader.load(CONFIG.fallbackUrlBase + cardData.fallback, (tex) => { tex.flipY = false; resolve(tex); }, undefined, () => resolve(createPlaceholderTexture())); }
        );
    });
}
function createCardBackTexture() {
    const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 860; const ctx = cvs.getContext('2d');
    const grd = ctx.createLinearGradient(0,0,512,860); grd.addColorStop(0, '#1a0505'); grd.addColorStop(1, '#000000');
    ctx.fillStyle = grd; ctx.fillRect(0,0,512,860);
    ctx.strokeStyle = '#aa5533'; ctx.lineWidth = 15; ctx.strokeRect(20,20,472,820);
    ctx.strokeStyle = '#cda732'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(256, 50); ctx.lineTo(256, 810); ctx.stroke();
    ctx.beginPath(); ctx.arc(256, 430, 120, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = '#cda732'; ctx.font = "bold 60px Serif"; ctx.textAlign = "center"; ctx.fillText("FATE", 256, 410);
    return new THREE.CanvasTexture(cvs);
}
function createPlaceholderTexture() {
    const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 400; const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#222'; ctx.fillRect(0,0,256,400); return new THREE.CanvasTexture(cvs);
}

function triggerTearEffect() {
    if (!activeCard) return;
    SoundFX.playTear();
    const flash = document.getElementById('tear-flash'); flash.style.opacity = 0.6; setTimeout(() => flash.style.opacity = 0, 80); 
    const cardMesh = activeCard.children[0]; const mats = cardMesh.material; 
    const frontMat = mats[4]; const backMat = mats[5]; const edgeMat = mats[0];
    const halfGeo = new THREE.BoxGeometry(CONFIG.cardSize.w / 2, CONFIG.cardSize.h, CONFIG.cardSize.d);
    
    const lFront = frontMat.clone(); lFront.map = frontMat.map.clone(); lFront.map.repeat.set(0.5, 1); lFront.map.offset.set(0.5, 0); 
    const lBack = backMat.clone(); lBack.map = backMat.map.clone(); lBack.map.repeat.set(0.5, 1); lBack.map.offset.set(0, 0);
    const leftMesh = new THREE.Mesh(halfGeo, [edgeMat, edgeMat, edgeMat, edgeMat, lFront, lBack]);
    
    const rFront = frontMat.clone(); rFront.map = frontMat.map.clone(); rFront.map.repeat.set(0.5, 1); rFront.map.offset.set(0, 0);
    const rBack = backMat.clone(); rBack.map = backMat.map.clone(); rBack.map.repeat.set(0.5, 1); rBack.map.offset.set(0.5, 0);
    const rightMesh = new THREE.Mesh(halfGeo, [edgeMat, edgeMat, edgeMat, edgeMat, rFront, rBack]);

    activeCard.updateMatrixWorld(); const pos = activeCard.position.clone(); const rot = activeCard.quaternion.clone();
    const leftGroup = new THREE.Group(); leftGroup.add(leftMesh); const rightGroup = new THREE.Group(); rightGroup.add(rightMesh);
    leftGroup.position.copy(pos); leftGroup.quaternion.copy(rot); rightGroup.position.copy(pos); rightGroup.quaternion.copy(rot);
    leftGroup.translateX(-CONFIG.cardSize.w / 4); rightGroup.translateX(CONFIG.cardSize.w / 4);

    tornParts.push({ mesh: leftGroup, vel: new THREE.Vector3(-0.05, 0.05, 0), rotVel: new THREE.Vector3(-0.05, 0, 0.1) });
    tornParts.push({ mesh: rightGroup, vel: new THREE.Vector3(0.05, 0.05, 0), rotVel: new THREE.Vector3(0.05, 0, -0.1) });
    scene.add(leftGroup); scene.add(rightGroup); createConfetti(pos);
    scene.remove(activeCard); activeCard = null; currentState = STATE.TEARING;
    updateUI(false); document.getElementById('tear-btn').style.display = 'none';
    setTimeout(() => { resetGame(); }, CONFIG.destroyDelay);
}
function createConfetti(pos) {
    const geo = new THREE.PlaneGeometry(0.08, 0.08); const mat = new THREE.MeshBasicMaterial({ color: 0xddccaa, side: THREE.DoubleSide });
    for(let i=0; i<15; i++) {
        const m = new THREE.Mesh(geo, mat); m.position.copy(pos); m.position.x += (Math.random()-0.5)*0.8; m.position.y += (Math.random()-0.5)*3;
        scene.add(m); tornParts.push({ mesh: m, vel: new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2), rotVel: new THREE.Vector3(Math.random()*0.3, Math.random()*0.3, 0) });
    }
}
function grabCardFromDeck(bgGroup) {
    if (activeCard) return; 
    SoundFX.playSelect(); activeCard = new THREE.Group(); activeCard.userData = bgGroup.userData;
    const originalMesh = bgGroup.children[0]; const geo = originalMesh.geometry; 
    const newMats = originalMesh.material.map(m => { const cm = m.clone(); cm.color.setHex(0xffffff); cm.emissive.setHex(0x000000); return cm; });
    const newMesh = new THREE.Mesh(geo, newMats); newMesh.castShadow = true; newMesh.receiveShadow = true;
    activeCard.add(newMesh); activeCard.position.copy(bgGroup.position); activeCard.rotation.copy(bgGroup.rotation);
    scene.add(activeCard); currentState = STATE.GRABBED;
}
function resetGame() {
    tornParts.forEach(p => scene.remove(p.mesh)); tornParts = [];
    activeCard = null; currentState = STATE.CAROUSEL; updateUI(false);
}

function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    raycaster.setFromCamera(cursor, camera);
    if(starField) starField.rotation.y += 0.0002;

    let targetIndex = Math.round(activeIndex); targetIndex = Math.max(0, Math.min(targetIndex, bgDeck.length - 1));
    smoothIndex += (targetIndex - smoothIndex) * 0.1;
    const currentRoundIndex = Math.round(smoothIndex);
    if (currentState === STATE.CAROUSEL && currentRoundIndex !== lastRoundIndex) { SoundFX.playSwipe(); lastRoundIndex = currentRoundIndex; }

    bgDeck.forEach((group, i) => {
        const offset = i - smoothIndex; const x = offset * CONFIG.carouselSpacing; const z = -Math.abs(offset) * 2.0 - 5; 
        group.position.set(x, Math.sin(time + i)*0.1, z); group.rotation.set(0, offset * -0.25 + Math.PI, 0); 
        const dim = activeCard ? 0.1 : 1.0; if(group.children[0]) group.children[0].material.forEach(m => { m.color.setScalar(dim); m.emissive.setScalar(0); });
    });

    if (currentState === STATE.CAROUSEL && !activeCard) {
        if (Math.abs(swipeVelocity) > 0.01) { smoothIndex += swipeVelocity; activeIndex = smoothIndex; swipeVelocity *= 0.9; }
        if (targetIndex >= 0 && targetIndex < bgDeck.length) {
            const bgGroup = bgDeck[targetIndex];
            if (!activeCard) { bgGroup.children[0].material.forEach((m, idx) => { if(idx < 4) m.emissive.setHex(0x553311); }); document.getElementById('cursor-tracker').classList.add('hovering'); }
            const threshold = isMobile ? 0.8 : 0.4;
            if (isPinching && Math.hypot(cursor.x, cursor.y) < threshold) grabCardFromDeck(bgGroup);
        }
    } else document.getElementById('cursor-tracker').classList.remove('hovering');

    if (activeCard && (currentState === STATE.GRABBED || currentState === STATE.REVEALED)) {
        const touchOffsetY = isMobile ? 0.1 : 0; const vec = new THREE.Vector3(cursor.x, cursor.y + touchOffsetY, 0.5); vec.unproject(camera);
        const dir = vec.sub(camera.position).normalize(); let targetPos;
        if ((Math.hypot(cursor.x, cursor.y) < 0.3 && isPinching) || currentState === STATE.REVEALED) {
            if (currentState !== STATE.REVEALED) { currentState = STATE.REVEALED; SoundFX.playFlip(); isReversed = Math.random() < 0.5; updateUI(true, activeCard.userData.data); }
            const displayDist = isMobile ? camera.position.z * 0.4 : 3.5; targetPos = new THREE.Vector3(0, 0, displayDist); 
        } else {
            targetPos = camera.position.clone().add(dir.multiplyScalar(isMobile ? 12 : 6));
            if(currentState !== STATE.REVEALED) { currentState = STATE.GRABBED; updateUI(false); }
        }
        activeCard.position.lerp(targetPos, 0.15);
        if (currentState === STATE.REVEALED) {
            const targetRot = new THREE.Euler(0, 0, isReversed ? Math.PI : 0); activeCard.quaternion.slerp(new THREE.Quaternion().setFromEuler(targetRot), 0.15);
        } else { activeCard.lookAt(camera.position); activeCard.rotateY(Math.PI); }
    }

    if (tornParts.length > 0) {
        for (let i = tornParts.length - 1; i >= 0; i--) {
            const p = tornParts[i]; p.vel.y -= 0.003; p.mesh.position.add(p.vel); p.mesh.rotation.x += p.rotVel.x; p.mesh.rotation.z += p.rotVel.z;
            if (p.mesh.position.y < -15) { scene.remove(p.mesh); tornParts.splice(i, 1); }
        }
    }
    renderer.render(scene, camera);
}

// --- 输入逻辑 ---
function setupInput() {
    // 鼠标/触摸事件
    const onMove = (x, y) => {
        if(inputMode !== INPUT.MOUSE) return;
        updateCursor(x, y);
        if (currentState === STATE.CAROUSEL && !isPinching) swipeVelocity -= (x - (window._lastX||x)) * 0.005;
        window._lastX = x;
    };
    document.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});

    const onDown = (x, y) => {
        if(inputMode === INPUT.MOUSE) {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             setPinch(true); updateCursor(x, y); window._lastX = x;
        }
    };
    document.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
    document.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY), {passive: false});

    const onUp = () => { if(inputMode === INPUT.MOUSE) setPinch(false); };
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);

    document.getElementById('tear-btn').addEventListener('click', (e) => { e.stopPropagation(); triggerTearEffect(); });

    // --- 摄像头开启逻辑 ---
    document.getElementById('toggle-cam').addEventListener('click', async () => {
        if(cameraActive) {
            // 如果已经开启，则关闭
            stopCamera();
            return;
        }

        // 检查 HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            alert('❌ 摄像头无法启动\n\n原因：浏览器要求必须使用 HTTPS 安全协议。\n\n解决方法：\n1. 将代码上传到 GitHub Pages 或 Vercel。\n2. 访问 https://your-site.com');
            return;
        }

        const btn = document.getElementById('toggle-cam');
        btn.innerText = "启动中...";
        
        try {
            await startCamera();
            cameraActive = true;
            inputMode = INPUT.HANDS;
            btn.innerText = "关闭摄像头";
            btn.classList.add('active');
            document.getElementById('instructions').innerText = "手势控制: 食指捏合=抓取 | 握拳=撕碎";
            document.getElementById('cursor-tracker').style.display = 'block';
        } catch (err) {
            console.error(err);
            alert("❌ 启动失败: " + err.message + "\n\n请确保已允许浏览器访问摄像头权限。");
            btn.innerText = "开启摄像头";
            inputMode = INPUT.MOUSE;
        }
    });
}

function updateCursor(screenX, screenY) {
    cursor.x = (screenX / window.innerWidth) * 2 - 1; cursor.y = -(screenY / window.innerHeight) * 2 + 1;
    const el = document.getElementById('cursor-tracker');
    el.style.left = screenX + 'px'; el.style.top = screenY + 'px';
}
function setPinch(val) {
    isPinching = val;
    const el = document.getElementById('cursor-tracker');
    if(val) el.classList.add('pinching'); else el.classList.remove('pinching');
}
function updateUI(show, data) {
    const el = document.getElementById('card-info'); const tearBtn = document.getElementById('tear-btn');
    if (show && data) {
        el.style.opacity = 1; tearBtn.style.display = 'block';
        document.getElementById('card-name').innerHTML = data.name + (isReversed ? " <span style='color:#f44;font-size:0.5em'>REVERSED</span>" : "");
        document.getElementById('card-meaning').innerText = isReversed ? data.reversed : data.upright;
    } else { el.style.opacity = 0; tearBtn.style.display = 'none'; }
}

// --- 摄像头核心逻辑 ---
async function startCamera() {
    const video = document.getElementById('input-video');
    
    // 初始化 Hands
    if(!handLandmarker) {
        handLandmarker = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        handLandmarker.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.65, minTrackingConfidence: 0.5 });
        handLandmarker.onResults(onHandResults);
    }
    
    // 请求权限流
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 320, height: 240 } });
    video.srcObject = stream;
    
    return new Promise((resolve) => {
        video.onloadedmetadata = () => {
            video.play();
            video.classList.add('active');
            // 使用 MediaPipe 的 Camera 工具库进行循环
            cameraObj = new Camera(video, { onFrame: async () => { await handLandmarker.send({image: video}); }, width: 320, height: 240 });
            cameraObj.start();
            resolve();
        };
    });
}

function stopCamera() {
    if(cameraObj) { cameraObj.stop(); cameraObj = null; }
    const video = document.getElementById('input-video');
    if(video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); video.srcObject = null; }
    video.classList.remove('active');
    
    cameraActive = false;
    inputMode = INPUT.MOUSE;
    const btn = document.getElementById('toggle-cam');
    btn.innerText = "开启摄像头";
    btn.classList.remove('active');
    document.getElementById('instructions').innerText = "触摸操作模式: 滑动/点击";
    document.getElementById('cursor-tracker').style.display = 'none';
}

function onHandResults(res) {
    if (inputMode !== INPUT.HANDS) return;
    if (res.multiHandLandmarks.length > 0) {
        const lm = res.multiHandLandmarks[0];
        const index = lm[8], thumb = lm[4], wrist = lm[0];
        // 映射坐标
        updateCursor((1 - index.x) * window.innerWidth, index.y * window.innerHeight);
        
        // 捏合检测
        const dist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
        setPinch(dist < 0.05);

        // 滑动逻辑
        if (currentState === STATE.CAROUSEL && !isPinching) {
            const dx = index.x - (window._lastHandX || index.x);
            if (Math.abs(dx) > 0.01) swipeVelocity += dx * 2.0;
            window._lastHandX = index.x;
        }

        // 握拳检测 (撕碎)
        const tips = [12, 16, 20];
        const isFistNow = tips.every(i => Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y) < 0.35) && dist < 0.1;
        if(currentState === STATE.REVEALED && isFistNow && !isFist) triggerTearEffect();
        isFist = isFistNow;
    } else {
        setPinch(false); isFist = false;
    }
}

window.onload = init;
</script>
</body>
</html>